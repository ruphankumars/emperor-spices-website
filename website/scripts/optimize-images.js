#!/usr/bin/env node
/**
 * Image Optimization Script
 * Converts PNG/JPG images to WebP and AVIF formats
 * Generates responsive image sizes and blur placeholders
 * 
 * Usage: node scripts/optimize-images.js
 */

import sharp from 'sharp';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const CONFIG = {
    inputDir: path.join(__dirname, '../public/images'),
    outputDir: path.join(__dirname, '../public/images/optimized'),
    
    // Responsive breakpoints
    sizes: [
        { width: 320, suffix: '-sm' },
        { width: 640, suffix: '-md' },
        { width: 1024, suffix: '-lg' },
        { width: 1920, suffix: '-xl' },
    ],
    
    // Quality settings
    quality: {
        webp: 80,
        avif: 65,
        jpeg: 85
    },
    
    // Blur placeholder settings
    blurPlaceholder: {
        width: 20,
        height: 20,
        blur: 10
    }
};

/**
 * Ensure output directory exists
 */
async function ensureDir(dir) {
    try {
        await fs.mkdir(dir, { recursive: true });
    } catch (err) {
        if (err.code !== 'EEXIST') throw err;
    }
}

/**
 * Generate a tiny base64 blur placeholder
 */
async function generateBlurPlaceholder(inputPath) {
    const buffer = await sharp(inputPath)
        .resize(CONFIG.blurPlaceholder.width, CONFIG.blurPlaceholder.height, {
            fit: 'cover'
        })
        .blur(CONFIG.blurPlaceholder.blur)
        .jpeg({ quality: 50 })
        .toBuffer();
    
    return `data:image/jpeg;base64,${buffer.toString('base64')}`;
}

/**
 * Process a single image file
 */
async function processImage(inputPath, filename) {
    const baseName = path.parse(filename).name;
    const metadata = await sharp(inputPath).metadata();
    const results = {
        original: filename,
        width: metadata.width,
        height: metadata.height,
        formats: {},
        responsive: [],
        blurDataUrl: null
    };
    
    console.log(`Processing: ${filename} (${metadata.width}x${metadata.height})`);
    
    // Generate blur placeholder
    results.blurDataUrl = await generateBlurPlaceholder(inputPath);
    console.log(`  âœ“ Generated blur placeholder`);
    
    // Generate full-size WebP and AVIF
    const webpPath = path.join(CONFIG.outputDir, `${baseName}.webp`);
    const avifPath = path.join(CONFIG.outputDir, `${baseName}.avif`);
    
    await sharp(inputPath)
        .webp({ quality: CONFIG.quality.webp })
        .toFile(webpPath);
    results.formats.webp = `/images/optimized/${baseName}.webp`;
    console.log(`  âœ“ Generated WebP`);
    
    await sharp(inputPath)
        .avif({ quality: CONFIG.quality.avif })
        .toFile(avifPath);
    results.formats.avif = `/images/optimized/${baseName}.avif`;
    console.log(`  âœ“ Generated AVIF`);
    
    // Generate responsive sizes
    for (const size of CONFIG.sizes) {
        // Skip if original is smaller than target size
        if (metadata.width <= size.width) continue;
        
        const responsiveBase = `${baseName}${size.suffix}`;
        
        // WebP responsive
        await sharp(inputPath)
            .resize(size.width, null, { withoutEnlargement: true })
            .webp({ quality: CONFIG.quality.webp })
            .toFile(path.join(CONFIG.outputDir, `${responsiveBase}.webp`));
        
        // AVIF responsive
        await sharp(inputPath)
            .resize(size.width, null, { withoutEnlargement: true })
            .avif({ quality: CONFIG.quality.avif })
            .toFile(path.join(CONFIG.outputDir, `${responsiveBase}.avif`));
        
        results.responsive.push({
            width: size.width,
            webp: `/images/optimized/${responsiveBase}.webp`,
            avif: `/images/optimized/${responsiveBase}.avif`
        });
        
        console.log(`  âœ“ Generated ${size.width}w variants`);
    }
    
    return results;
}

/**
 * Generate image manifest file
 */
async function generateManifest(imageData) {
    const manifestPath = path.join(__dirname, '../src/utils/imageManifest.js');
    
    const manifest = `/**
 * Auto-generated image manifest
 * Generated by: scripts/optimize-images.js
 * DO NOT EDIT MANUALLY
 */

export const IMAGE_MANIFEST = ${JSON.stringify(imageData, null, 2)};

/**
 * Get optimized image sources for a given image path
 * @param {string} originalPath - Original image path (e.g., '/images/cardamom-pods.png')
 * @returns {Object} Optimized image data including formats, responsive sizes, and blur placeholder
 */
export function getOptimizedImage(originalPath) {
    // Normalize path
    const normalized = originalPath.replace(/^\\/images\\//, '');
    return IMAGE_MANIFEST[normalized] || null;
}

/**
 * Generate srcset string for responsive images
 * @param {Object} imageData - Image data from manifest
 * @param {string} format - 'webp' or 'avif'
 * @returns {string} srcset string
 */
export function generateSrcSet(imageData, format = 'webp') {
    if (!imageData || !imageData.responsive || imageData.responsive.length === 0) {
        return imageData?.formats?.[format] || '';
    }
    
    const srcset = imageData.responsive
        .map(r => \`\${r[format]} \${r.width}w\`)
        .join(', ');
    
    // Add full size as the largest option
    if (imageData.formats?.[format]) {
        return \`\${srcset}, \${imageData.formats[format]} \${imageData.width}w\`;
    }
    
    return srcset;
}

/**
 * Get the default sizes attribute based on common breakpoints
 */
export function getDefaultSizes() {
    return '(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw';
}
`;

    await fs.writeFile(manifestPath, manifest);
    console.log(`\nâœ“ Generated image manifest: ${manifestPath}`);
}

/**
 * Main function
 */
async function main() {
    console.log('ðŸ–¼ï¸  Image Optimization Script\n');
    console.log('Input directory:', CONFIG.inputDir);
    console.log('Output directory:', CONFIG.outputDir);
    console.log('');
    
    // Ensure output directory exists
    await ensureDir(CONFIG.outputDir);
    
    // Get list of images to process
    const files = await fs.readdir(CONFIG.inputDir);
    const imageFiles = files.filter(f => 
        /\.(png|jpg|jpeg|gif)$/i.test(f) && !f.startsWith('.')
    );
    
    if (imageFiles.length === 0) {
        console.log('No images found to process.');
        return;
    }
    
    console.log(`Found ${imageFiles.length} images to process\n`);
    
    // Process each image
    const imageData = {};
    
    for (const filename of imageFiles) {
        const inputPath = path.join(CONFIG.inputDir, filename);
        try {
            const result = await processImage(inputPath, filename);
            imageData[filename] = result;
            console.log('');
        } catch (err) {
            console.error(`  âœ— Error processing ${filename}:`, err.message);
        }
    }
    
    // Generate manifest file
    await generateManifest(imageData);
    
    // Calculate size savings
    console.log('\nðŸ“Š Optimization Complete!\n');
    
    // Log summary
    const processed = Object.keys(imageData).length;
    console.log(`Processed: ${processed} images`);
    console.log(`Generated formats: WebP, AVIF`);
    console.log(`Responsive sizes: ${CONFIG.sizes.map(s => s.width + 'w').join(', ')}`);
    console.log(`Blur placeholders: âœ“`);
}

// Run the script
main().catch(console.error);
